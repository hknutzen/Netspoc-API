#!/bin/bash

# Checkin changed files into CVS

# Abort on each error
set -e

# Check parameter
verbose=''
if getopts 'v' flag; then
    shift
    verbose=1
fi

abort-err () { echo "$*" >&2; cat err >&2; exit 1; }
info () { [ $verbose ] && echo "$*" >&2 || true; }

# Add job IDs and CRQs to commit message.
[ $# -gt 1 ] && S=s
MSG="API job$S:"
for file in $(ls -rt $*); do
    job=$(basename $file)
    MSG="$MSG $job"
done

# Get CRQs from all jobs given as arguments.
CRQ=$(jq -r '.crq | values' $* | sort -u | paste -s -d' ')
[ -n "$CRQ" ] && MSG="$MSG
$CRQ"


# Try to check in.
while true; do
    info "Committing changes"
    if cvs -q commit -m"$MSG" netspoc >/dev/null 2>err; then
        info "Success"
        break
    fi
    # Try again if Up-to-date check failed,
    # i.e. both given messages are ignored.
    # Don't check for exact name of "cvs" command in message,
    # because cvs command may have been changed by $CVS_Server.
    if [ -n "$(cat err | egrep -v '^[^ ]+ commit: Up-to-date check failed for|^[^ ]+ \[commit aborted\]: correct above errors first!$')" ] ; then
        abort-err "Error during cvs commit:"
    fi
    cvs -q update netspoc >/dev/null 2>err ||
        abort-err "Error during cvs update (after change):"
    # Check for merge conflict
    if [ -n "$(cat err | egrep '^[^ ]+ update: conflicts found in')" ] ; then
        abort-err "Merge conflict during cvs update:"
    fi
done
