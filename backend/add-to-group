#!/usr/bin/env perl

=head1 NAME

add-to-group - Add object to  existing group

=head1 SYNOPSIS

add-to-group group-name object

=head1 COPYRIGHT AND DISCLAIMER

(c) 2019 by Heinz Knutzen <heinz.knutzen@googlemail.com>

http://hknutzen.github.com/Netspoc-API

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.
This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU General Public License for more details.
You should have received a copy of the GNU General Public License
along with this program. If not, see <http://www.gnu.org/licenses/>.

=cut

use strict;
use warnings;
use open qw(:std :utf8);
use Pod::Usage;

sub abort {
    my (@args) = @_;
    die "Error: ", @args, "\n";
}

sub find_ip {
    my ($name) = @_;
    if(my ($ip) = $name =~ /(\d+_\d+_\d+_\d+)$/) {
        $ip =~ s/_/./g;
        return $ip;
    }
    return '0.0.0.0';
}

sub ip2bitstr {
    my ($ip) = @_;
    return pack 'C4', split('\.', $ip);
}

sub compare_ip {
    my ($ip1, $ip2) = @_;
    return ip2bitstr($ip1) cmp ip2bitstr($ip2);
}

####################################################################
# Argument processing
####################################################################

# Make @ARGV utf-8.
$_ = Encode::decode('UTF-8' , $_) for @ARGV;

my $group_name = shift @ARGV or pod2usage(2);
my $object = shift @ARGV or pod2usage(2);
@ARGV and pod2usage(2);

####################################################################
# Main program
####################################################################

# Read to be changed lines from STDIN.
my @lines = <>;

# Number of current line.
my $pos = 0;

# Range of line numbers, where objects are expected.
my $start_pos;
my $end_pos;

# Find definition of to be changed group.
# "=" must be located on same line.
while ($pos < @lines) {
    if ($lines[$pos] =~ /^ \s* group:$group_name \s* =/x) {
        $start_pos = $pos;
        last;
    }
    $pos++;
}
if (not defined $start_pos) {
    abort("Can't find group:$group_name");
}

# Find end of group.
while ($pos < @lines) {
    if ($lines[$pos] =~ /^ [^#]* ; /x) {
        $end_pos = $pos;
        last;
    }
    $pos++;
}
if (not defined $end_pos) {
    abort("Can't find terminating ';' of group:$group_name");
}

# Split line, if terminating ';' isn't located on separate line.
# Ignore trailing whitespace after first part.
# Leave comment at first part.
# Add missing comma after first part.
if ($lines[$pos] =~ /^ (.+?) \s* (; [^\n]*? ) (\s*[#].*)? $/x) {
    my $prefix = $1;
    my $semi = $2;
    my $comment = $3 ||'';
    if ($prefix !~ /[,=] \s* $/x) {
        $prefix .= ',';
    }
    splice(@lines, $pos, 1, "$prefix$comment\n", "$semi\n");
    $end_pos++;
}

# Search $pos, where to insert new object.
# - Identical typed objects are place together.
#   Possibly, block of networks is placed before block of hosts.
# - Use IP address contained in name for comparing.
# Insert before next larger object.
# If no larger object is found, insert before terminating semicolon.
$pos = $start_pos + 1;
my ($obj_type, $obj_name) = split ':', $object;
if (my @block = grep { $lines[$_] =~ /^ \s* $obj_type: /x } $pos .. $end_pos) {
    my $obj_ip = find_ip($obj_name);
    $pos = undef;
    for my $i (@block) {
        my ($name) = $lines[$i] =~ /^ \s* $obj_type:([-\w]+) /x;
        my $ip = find_ip($name);

        # No IP found, compare lexically.
        if ($ip eq '0.0.0.0' and $obj_ip eq $ip) {
            if ($obj_name lt $name) {
                $pos = $i;
                last;
            }
        }

        # Found IP is larger, hence insert at this line
        elsif (compare_ip($obj_ip, $ip) < 0) {
            $pos = $i;
            last;
        }
    }
    $pos //= $block[-1] + 1;
}
else {
    $pos = $end_pos;
}

# If found object has comment line(s), insert before comment.
if ($pos < $end_pos) {
    while ($lines[$pos - 1] =~ /^\s*#/) {
        $pos--;
    }
}

# Insert new object at found position.
my $new = " $object,\n";
splice(@lines, $pos, 0, $new);


# Write changed lines to STDOUT.
print @lines;
