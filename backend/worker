#!/bin/bash

# Process job for Netspoc-API
USAGE="Usage: $0 FILE"

# - Get name of job file as argument,
# - read method and params from job
# - find to be processed netspoc file
# - call filter with found file as STDIN, writing changed content to STDOUT
# - write output to tempfile
# - make original file writable
# - move tempfile to original file


# Abort on each error
set -e

# Work in $HOME where paths are known.
cd $HOME

# Ignore this files in netspoc directory
EGREP='egrep --exclude='*~' --exclude='.#*' --exclude-dir=CVS'

abort () { echo "Error: $*" >&2; exit 1; }

# Parameters are names of JSON attributes,
# also used as shell variables.
# Use "@name" for JSON attribute with array value.
get_params () {
    local query=''
    local q=''
    for i in $* ; do

        # Convert string "a" to 'a', array ["a", "b"] to 'a,b'
        case $i in
            @*)
                i=$(echo $i | sed 's/^@//')
                q=".$i | if . then . | join(\",\") else . end"
                ;;
            *)
                q=".$i | values"
                ;;
        esac
        [ -n "$query" ] && query="$query, "
        query="$query\"$i=\($q)\""
    done

    eval "$(jq -r ".params | @sh $query" $job)"
}

# Search file containing definition.
# Store filename in $found.
find_file () {
    def=$1
    # Collect filenames into array
    found=($($EGREP -rl "^[[:space:]]*$def[[:space:]]*=" netspoc)) ||
            abort "Can't find '$def' in netspoc"
    [ ${#found[*]} -gt 1 ] &&
        abort "Found multiple occurrences of '$def' in:" ${found[*]} ||
            true
}
# Functions set global variables:
# $found: filename that is to be processed
# $args: Array with arguments to $filter command
create_host () {
    get_params network name ip owner mask
    if [ "$network" = '[auto]' ] ; then
        # Convert host IP and mask to network IP/prefixlen.
        local net_addr=$(bin/net-addr $ip $mask)
        local pattern=$(echo $net_addr | sed 's/[.]/\\./g')
        pattern="^[^#]*ip[[:space:]]*=[[:space:]]*$pattern"
        # Search files containing IP pattern
        # and collect found filenames into array
        found=($($EGREP -rl "$pattern" netspoc )) ||
            abort "Can't find network with 'ip = $net_addr' in netspoc/"
        [ ${#found[*]} -gt 1 ] &&
            abort "Found multiple occurrences of 'ip = $net_addr' in:" \
                  ${found[*]}
        # Check for multiple occurrences of IP in found file.
        [ $(egrep "$pattern" $found | wc -l) -gt 1 ] &&
            abort "Found multiple networks with 'ip = $net_addr' in: $found"
        # Find occurrences of network:NAME up to 20 lines before IP pattern.
        network=$(egrep -B20 "$pattern" $found |
                         egrep '^[^#]+' |
                         egrep -o 'network:[^[:space:]]+' |
                         tail -n1)
        [ -n "$network" ] ||
            abort "Can't find network definition for 'ip = $net_addr' in $found"
         network=$(echo $network | cut -d: -f2)
    else
        find_file "network:$network"
    fi
    args=($network $name $ip $owner)
}

modify_host () {
    get_params name owner
    find_file "host:$name"
    args=($name $owner)
}

create_owner () {
    get_params name @admins @watchers ok_if_exists
    found=netspoc/owner
    if $EGREP -q "^[[:space:]]*owner:$name[[:space:]]*=" $found; then
        if [ -n "$ok_if_exists" ] ; then

            # Owner already exists, nothing to do
            exit 0
        fi
    fi
    # Create owner regardless of existing one; this will result in error.
    found=netspoc/owner
    args=($name "$admins" "$watchers")
}

modify_owner () {
    get_params name @admins @watchers
    find_file "owner:$name"
    # If value is 'null' then leave value unchanged.
    # If value is '' (empty) then remove attribute.
    args=($name "$admins" "$watchers")
}

delete_owner () {
    get_params name
    find_file "owner:$name"
    args=($name)
}

add_to_group () {
    get_params name object
    find_file "group:$name"
    args=($name $object)
}

# Call this script recursively for each sub-job
multi_job () {
    local last=$(jq '.params | .jobs | length - 1' $job)
    for i in $(seq 0 $last) ; do
        local subjob="$job-$i"
        jq ".params | .jobs[$i]" $job > $subjob
        $0 $subjob
    done
}


[ $# -eq 1 ] || abort $USAGE
job=$1

# Sets global variable $filter:
# Command that reads from STDIN and writes to STDOUT.
method=$(jq -r '.method' $job)
case $method in
    create_host|modify_host|create_owner|modify_owner|delete_owner|add_to_group)
        filter="bin/$(echo $method | sed 's/_/-/g')"
        $method
        ;;
    multi_job)
        $method
        exit 0
        ;;
    *)
        abort "Unknown method '$method'"
esac

tmpfile=$(mktemp -p $HOME)
trap "rm -f $tmpfile" EXIT
# Call filter with args on found file.
$filter "${args[@]}" < $found > $tmpfile
# Move tempfile to original file.
chmod u+w $found
mv $tmpfile $found
chmod go+r $found
