#!/bin/bash

usage () {
    echo "Usage: $0 [user@]remote worker-command" >&2
    exit 1
}

[ $# -eq 2 ] || usage

# Username and hostname or IP of remote server, where jobs arrive.
# Used by ssh and scp.
REMOTE=$1

# Program that processes jobs, one by one.
# Path to job is given as argument, errors are written to STDERR.
WORKER=$2

# Wait that many seconds before retry after error.
WAIT_ERR=10

# Append content of file 'err' together with time stamp to file 'log'.
log () {
    echo -n 'Date: ' >>log
    date >>log
    cat err >>log
}

# Log error, if it occurs for first time.
# If this type of error has already been logged then log nothing,
# but wait for $WAIT_ERR seconds.
log-wait () {
    local STATUS="status/$1"
    if [ -f $STATUS ] ; then
        sleep $WAIT_ERR
    else
        touch $STATUS
        log
    fi
}

# Reset error status to ok, so this type of error will be logged again.
status-ok () {
    local STATUS="status/$1"
    rm -f $STATUS
}

# Execute $cmd repeatedly until success.
# Errors are written to file 'err' and logged once.
retry () {
    local cmd=$1
    local STATUS=$2
    while true; do
        $cmd 2>err ||
            # On failure, log once, wait and try again.
            { log-wait $STATUS; continue; }
        status-ok $STATUS
        break
    done
}

# Wait for next job on remote server,
# move it from "waiting" to "inprogress",
# copy job to "inprogress" on local server,
# set global variable INPROGRESS to "inprogress/job-id".
get-job () {
    while true; do
        INPROGRESS=$(ssh -q $REMOTE <<'EOF' 2>err
# Execute on remote server.
# Abort on every error.
set -e
JOB=$(ls inprogress | head -n1)

# Found stale job in "inprogress".
if [ -n "$JOB" ] ; then
    # Job already has been finished.
    if [ -f finished/$JOB ] ; then
        rm inprogress/$JOB
    else
        # Process this job again.
        # Announce found file to STDOUT.
        echo inprogress/$JOB
        exit
    fi
fi

# Wait for jobs appearing in directory "waiting".
while true; do
    # Take oldest job: first element of list
    JOB=$(ls -rt waiting | head -n1)
    if [ -n "$JOB" ] ; then
        # Found job, move from "waiting" to "inprogress".
        # Announce found file on STDOUT.
        mv waiting/$JOB inprogress/$JOB
        echo inprogress/$JOB
        exit
    fi
    # No job found, wait and check again
    sleep 1
done
EOF
                  ) ||
            # On failure, log once, wait and try again.
            { log-wait ssh-get; continue; }
        status-ok ssh-get
        break
    done
    retry "scp -q $REMOTE:$INPROGRESS $INPROGRESS" scp-get
}

# Move result/job-id to remote server: result/job-id
# Remove inprogress/job-id locally and move to finished/ at remote server.
mark-finished () {
    local JOB=$1
    local RESULT=result/$JOB
    local INPROGRESS=inprogress/$JOB
    local FINISHED=finished/$JOB
    retry "scp -q $RESULT $REMOTE:$RESULT" scp-put
    retry "ssh -q $REMOTE mv $INPROGRESS $FINISHED" ssh-move
    rm $RESULT
    rm -f $INPROGRESS
}

mkdir -p inprogress result status
while true; do

    # Read job names.
    # Only one name expected and only process first found job.
    RESULT=$(ls result | head -n1)
    if [ -z "$RESULT" ] ; then
        INPROGRESS=$(ls inprogress | head -n1)
        if [ -z "$INPROGRESS" ] ; then
            # Wait for next job, set global variable INPROGRESS.
            get-job
        fi
        JOB=$(basename $INPROGRESS)
        RESULT=result/$JOB
        TMP=$(mktemp -p .)
        # Store errors in $RESULT.
        # File is emtpy on success.
        $WORKER $INPROGRESS 2>$TMP ||
            grep -q '[^[:space:]]' $TMP ||
            echo "Unknown error" > $TMP
        mv $TMP $RESULT
    else
        JOB=$(basename $INPROGRESS)
    fi
    mark-finished $JOB
done
