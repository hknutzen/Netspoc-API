#!/bin/bash

# Process job for Netspoc-API
USAGE="Usage: $0 FILE"

# - Get name of job file as argument,
# - read method and params from job
# - find to be processed netspoc file
# - call filter with found file as STDIN, writing changed content to STDOUT
# - write output to tempfile
# - make original file writable
# - move tempfile to original file


# Abort on each error
set -e

# Work in $HOME where paths are known.
cd $HOME

# Ignore this files in netspoc directory
EGREP='egrep --exclude='*~' --exclude='.#*' --exclude-dir=CVS'

abort () { echo "Error: $*" >&2; exit 1; }

# Parameters are names of JSON attributes,
# also used as shell variables.
# Use "@name" for JSON attribute with array value.
get_params () {
    local query=''
    local q=''
    for i in $* ; do

        # Convert string "a" to 'a', array ["a", "b"] to 'a,b'
        case $i in
            @*)
                i=$(echo $i | sed 's/^@//')
                q=".$i | if . then . | join(\",\") else . end"
                ;;
            *)
                q=".$i | values"
                ;;
        esac
        [ -n "$query" ] && query="$query, "
        query="$query\"$i=\($q)\""
    done

    eval "$(jq -r ".params | @sh $query" $job)"
}

# Functions set global variables:
# $found: filename that is to be processed
# $filter: command line that reads from STDIN and writes to STDOUT
create_host () {
    get_params network name ip owner mask
    if [ "$network" = '[auto]' ] ; then
        # Convert host IP and mask to network IP/prefixlen.
        local net_addr=$(bin/net-addr $ip $mask)
        local pattern=$(echo $net_addr | sed 's/[.]/\\./g')
        pattern="^[^#]*ip[[:space:]]*=[[:space:]]*$pattern"
        # Search files containing IP pattern
        # and collect found filenames into array
        found=($($EGREP -rl "$pattern" netspoc )) ||
            abort "Can't find network with 'ip = $net_addr' in netspoc/"
        [ ${#found[*]} -gt 1 ] &&
            abort "Found multiple occurrences of 'ip = $net_addr' in:" \
                  ${found[*]}
        # Find occurrences of network:NAME up to 20 lines before IP pattern.
        network=($(egrep -B20 "$pattern" $found |
                         egrep '^[^#]+' |
                         egrep -o 'network:[^[:space:]]+')) ||
            abort "Can't find network definition for 'ip = $net_addr' in $found"
        [ ${#network[*]} -gt 1 ] &&
            abort "Found multiple networks with 'ip = $net_addr' in $found:" \
                  ${network[*]}
        network=$(echo $network | cut -d: -f2)
    else
        # Search files containing network definition
        # and collect found filenames into array
        found=($($EGREP -rl "^[[:space:]]*network:$network[[:space:]]*=" netspoc)) ||
            abort "Can't find 'network:$network' in netspoc"
        [ ${#found[*]} -gt 1 ] &&
            abort "Found multiple occurrences of 'network:$network' in:" \
                  ${found[*]}
    fi
    filter="bin/create-host $network $name $ip"
    if [ -n "$owner" ] ; then
        filter="$filter $owner"
    fi
}

create_owner () {
    get_params name @admins @watchers ok_if_exists
    found=netspoc/owner
    if $EGREP -q "^[[:space:]]*owner:$name[[:space:]]*=" $found; then
        if [ -n "$ok_if_exists" ] ; then

            # Owner already exists, nothing to do
            exit 0
        fi
    fi
    filter="bin/create-owner $name $admins"
    if [ "$watchers" != 'null' ] ; then
        filter="$filter $watchers"
    fi
}

add_to_group () {
    get_params name object
    # Search files containing group definition
    # and collect found filenames into array
    found=($($EGREP -rl "^[[:space:]]*group:$name[[:space:]]*=" netspoc)) ||
            abort "Can't find 'group:$name' in netspoc"
    [ ${#found[*]} -gt 1 ] &&
        abort "Found multiple occurrences of 'group:$name' in:" ${found[*]}
    filter="bin/add-to-group $name $object"
}

# Call this script recursively for each sub job
multi_job () {
    local last=$(jq '.params | .jobs | length - 1' $job)
    for i in $(seq 0 $last) ; do
        local subjob="$job-$i"
        jq ".params | .jobs[$i]" $job > $subjob
        $0 $subjob
    done
}


[ $# -eq 1 ] || abort $USAGE
job=$1

method=$(jq -r '.method' $job)
case $method in
    create_host|create_owner|add_to_group)
        $method
        ;;
    multi_job)
        $method
        exit 0
        ;;
    *)
        abort "Unknown method '$method'"
esac

tmpfile=$(mktemp -p $HOME)
trap "rm -f $tmpfile" EXIT
$filter < $found > $tmpfile
# Move tempfile to original file.
chmod u+w $found
mv $tmpfile $found
chmod go+r $found
